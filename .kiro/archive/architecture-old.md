# NecroCode Architecture

## Quick Reference
- **Purpose**: Explain how NecroCode is assembled and how data flows through the system.
- **Audience**: Architects, senior engineers, and spirits extending the framework.
- **Read Next**: Product framing → `overview.md`, implementation guide → `development.md`.

## System Context
NecroCode ingests a job description, decomposes it into specs in `.kiro/specs/`, and executes those specs through cooperating spirits. The orchestration stack is split across:
- `framework/orchestrator/` (Necromancer, issue routing, workload monitoring)
- `framework/workspace_manager/` (workspace lifecycle + Git automation)
- `necrocode/task_registry/` (stateful task/event persistence)
- `framework/agents/` + `strandsagents/` (LLM-backed execution helpers)
- Optional services (Artifact Store, Repo Pool Manager, Dispatcher, Review PR Service) defined in `.kiro/specs/*`.

## Technology Stack
| Concern | Implementation |
| --- | --- |
| Language / Runtime | Python 3.11+, `dataclasses`, `typing`, `asyncio`-ready components |
| Data & Persistence | JSON files for registry/event logs (`necrocode/task_registry`), file-based locks |
| Version Control | Native git CLI via `framework/workspace_manager/git_operations.py`, GitHub for PRs |
| AI / LLM | OpenAI GPT-5 Codex via `strandsagents.llm.OpenAIChatClient` |
| Messaging | Spirit Protocol payloads exchanged through message bus utilities (planned in dispatcher spec) |

## Architectural Patterns
- **Multi-Spirit Orchestration**: Necromancer summons multiple instances per role and balances load (see `.kiro/specs/necrocode-agent-orchestration`).
- **Workspace Isolation**: Every spec executes inside a dedicated cloned workspace tracked by `WorkspaceManager`.
- **Event Sourcing**: Task/Event stores append immutable logs that feed query engines (`necrocode/task_registry/event_store.py`).
- **Pluggable Services**: Artifact Store, Repo Pool Manager, Agent Runner, and Review PR Service are standalone services that integrate via Spirit Protocol + Task Registry.

## Spirit Protocol Specification
- **Commit Format**: `spirit(<scope>): <spell description> [Task <spec-task-id>]`. Example: `spirit(frontend): craft login form [Task 2.1]`.
- **Branch Naming**: `feature/task-{spec-id}-{task-number}-{slug}` or `{role}/spirit-{instance}/{feature}` when multiple instances operate simultaneously. Slugs are sanitized through `framework/workspace_manager/branch_strategy.py`.
- **Message Envelope**:
  ```json
  {
    "type": "issue_assignment",
    "agent_instance": "frontend_spirit_2",
    "issue_id": "login-ui",
    "payload": {
      "task": "2.1",
      "dependencies": ["1.1"],
      "context": "requirements + design extracts"
    }
  }
  ```
- **Metadata**: Each message or commit references `spec_id`, `task_id`, `agent_instance`, and optionally `issue_id` to enable traceability inside the Task Registry.

## Core Components
### Necromancer (`framework/orchestrator/necromancer.py`)
Parses job descriptions, assembles spirit teams, and coordinates sprint execution. Collaborates with IssueRouter, WorkspaceManager, and TaskRegistry to keep tasks flowing.

### Issue Router (`framework/orchestrator/issue_router.py`)
Routes backlog items to the best spirit type/instance using keyword rules and workload awareness. Supports bilingual keyword dictionaries and least-busy scheduling.

### Workspace Manager (`framework/workspace_manager/*.py`)
Owns workspace lifecycle: cloning repos, generating branches/commits, pushing changes, and persisting workspace state (`state_tracker.py`). Enforces Spirit Protocol naming via `branch_strategy.py`.

### Repo Pool Manager (spec in `.kiro/specs/repo-pool-manager`)
Service responsible for keeping a pool of warm git workspaces ready for agents. It handles slot allocation, slot cleaning, LRU assignment, and stale lock cleanup.

### Agent Runner (`.kiro/specs/agent-runner`)
Executes individual spec tasks by coordinating workspace operations, TestRunner, ArtifactUploader, and PlaybookEngine. The RunnerOrchestrator integrates with Task Registry + Artifact Store.

### Artifact Store (`.kiro/specs/artifact-store`)
Persists diffs, logs, test outputs, and binary artifacts generated by spirits. Provides retrieval APIs for Review PR Service and downstream tooling.

### Task Registry (`necrocode/task_registry/*`)
Source of truth for specs, tasks, task states, events, and artifacts. Components include `task_store.py`, `event_store.py`, `lock_manager.py`, and querying/graph visualization helpers.

### Dispatcher & Review PR Service
Dispatcher assigns ready tasks to runners based on skills/availability. Review PR Service consumes commits/artifacts, runs review heuristics, and reports findings back to the registry.

## Data Models
- **Taskset / Task / TaskEvent** – defined in `necrocode/task_registry/models.py`, capture spec metadata, dependency graphs, and lifecycle events.
- **Artifact** – stored alongside tasks with `type`, `uri`, size, and timestamps (`task_registry/task_registry.py::add_artifact`).
- **WorkspaceInfo** – persisted via `framework/workspace_manager/state_tracker.py` with workspace path, repo URL, branch, and status flags.
- **AgentInstance & Issue** – defined in `.kiro/specs/necrocode-agent-orchestration` implementation; hold routing metadata (role, workload, assigned branches).
- **Slot / Pool / AllocationMetrics** – planned data models for Repo Pool Manager, ensuring slots are persisted with state and health information.

## Quality Attributes
- **Performance**: Workspace creation dominated by git clone/pull; state and registry operations are O(1) file writes; issue routing is O(n) relative to agent instances.
- **Security**: Secrets pulled from environment (e.g., `OPENAI_API_KEY`), no secrets persisted in logs. Workspace isolation avoids cross-contamination. Artifact URIs reference storage backends with access controls.
- **Scalability**: Horizontal scale via multiple agent instances + Repo Pool Manager slots. Task Registry handles concurrent updates through file locks. Dispatcher/Agent Runner specs describe stateless workers.
- **Observability**: Structured logging for routing/runner decisions, event logs in `event_store.py`, metrics hooks outlined in agent-runner spec for future Prometheus reporting.

## Cross-References
- For terminology + product framing: `overview.md`
- For directory layout, coding standards, and workflows: `development.md`
- For service-level requirements: `.kiro/specs/*/requirements.md`
